#include <bid/bid.h>

static void gen_type(BidInterface const *interface, BidType const *type, IoWriter *writer);

static bool type_in_interface(BidInterface const *interface, Str name)
{
    vec_foreach(type, &interface->aliases)
    {
        if (str_eq(type.name, name))
        {
            return true;
        }
    }

    return false;
}

static void gen_generic(BidInterface const *interface, BidGeneric const *type, IoWriter *writer)
{
    if (type_in_interface(interface, type->name))
    {
        print(writer, "{case:pascal}", interface->name);
    }

    print(writer, "{}", type->name);

    if (type->params.length)
    {
        io_print(writer, str_cast("("));

        for (int i = 0; i < type->params.length; i++)
        {
            gen_type(interface, &type->params.data[i], writer);

            if (i + 1 != type->params.length)
            {
                io_print(writer, str_cast(","));
            }
        }

        io_print(writer, str_cast(")"));
    }
}

static void gen_enum(BidInterface const *interface, BidEnum const *type, IoWriter *writer)
{
    io_print(writer, str_cast("enum {\n"));

    vec_foreach(member, &type->members)
    {
        print(writer, "{case:upper}_{case:upper},\n", interface->name, member);
    }

    io_print(writer, str_cast("}"));
}

static void gen_struct(BidInterface const *interface, BidStruct const *type, IoWriter *writer)
{
    io_print(writer, str_cast("struct {\n"));

    vec_foreach(member, &type->members)
    {
        gen_type(interface, &member.type, writer);
        print(writer, " {};\n", member.name);
    }

    io_print(writer, str_cast("}"));
}

static void gen_type(BidInterface const *interface, BidType const *type, IoWriter *writer)
{
    switch (type->type)
    {
    case BID_TYPE_GENERIC:
        gen_generic(interface, &type->generic_, writer);
        break;

    case BID_TYPE_ENUM:
        gen_enum(interface, &type->enum_, writer);
        break;

    case BID_TYPE_STRUCT:
        gen_struct(interface, &type->struct_, writer);
        break;

    default:
        break;
    }
}

void bid2c(BidInterface const *interface, IoWriter *writer)
{
    print(writer, "#pragma once\n"
                  "\n"
                  "// This is file is auto generated by BID, don't edit it!\n"
                  "\n"
                  "#include <syscalls/types.h>\n"
                  "\n");

    print(writer, "typedef ");
    gen_enum(interface, &interface->errors, writer);
    print(writer, " {case:pascal}Error;\n", interface->name);

    print(writer, "\n");

    print(writer, "/* --- Types ---------------------------------------------------------------- */\n\n");

    vec_foreach(alias, &interface->aliases)
    {
        print(writer, "typedef ");
        gen_type(interface, &alias.type, writer);
        print(writer, " {case:pascal}{case:pascal};\n", interface->name, alias.name);
        print(writer, "\n");
    }

    print(writer, "/* --- Messages ------------------------------------------------------------- */\n\n");

    vec_foreach(method, &interface->methods)
    {
        print(writer, "typedef ");
        gen_type(interface, &method.request, writer);
        print(writer, " {case:pascal}{case:pascal}Request;\n", interface->name, method.name);

        print(writer, "\n");

        print(writer, "typedef ");
        gen_type(interface, &method.response, writer);
        print(writer, " {case:pascal}{case:pascal}Response;\n", interface->name, method.name);

        print(writer, "\n");
    }

    vec_foreach(event, &interface->events)
    {
        print(writer, "typedef ");
        gen_type(interface, &event.data, writer);
        print(writer, " {case:pascal}{case:pascal}Event;\n", interface->name, event.name);
        print(writer, "\n");
    }

    print(writer, "typedef enum {{\n");

    print(writer, "{case:upper}_INVALID,\n", interface->name);
    print(writer, "{case:upper}_ERROR,\n", interface->name);

    vec_foreach(method, &interface->methods)
    {
        print(writer, "{case:upper}_{case:upper}_REQUEST,\n", interface->name, method.name);
        print(writer, "{case:upper}_{case:upper}_RESPONSE,\n", interface->name, method.name);
    }

    vec_foreach(event, &interface->events)
    {
        print(writer, "{case:upper}_{case:upper}_EVENT,\n", interface->name, event.name);
    }

    print(writer, "}} {case:pascal}MessageType;\n", interface->name);

    print(writer, "\n");

    print(writer, "typedef struct {{\n");

    print(writer, "BrMsgHeader header;\n");

    print(writer, "union {{\n");
    print(writer, "{case:pascal}Error error;\n", interface->name);

    vec_foreach(event, &interface->events)
    {
        print(writer, "{case:pascal}{case:pascal}Event {case:sake}_event;\n", interface->name, event.name, event.name);
    }

    vec_foreach(method, &interface->methods)
    {
        print(writer, "{case:pascal}{case:pascal}Request {case:sake}_request;\n", interface->name, method.name, method.name);
        print(writer, "{case:pascal}{case:pascal}Response {case:sake}_response;\n", interface->name, method.name, method.name);
    }

    print(writer, "}};\n");

    print(writer, "}} {case:pascal}Message;\n", interface->name);
}
