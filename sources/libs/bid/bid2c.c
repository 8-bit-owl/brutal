#include <bid/bid.h>

static void emit_type(BidInterface const *interface, BidType const *type, Emit *emit);

static bool type_in_interface(BidInterface const *interface, Str name)
{
    vec_foreach(type, &interface->aliases)
    {
        if (str_eq(type.name, name))
        {
            return true;
        }
    }

    return false;
}

static void emit_generic(BidInterface const *interface, BidGeneric const *type, Emit *emit)
{
    if (type_in_interface(interface, type->name))
    {
        emit_fmt(emit, "{case:pascal}", interface->name);
    }

    emit_fmt(emit, "{}", type->name);

    if (type->params.length)
    {
        emit_fmt(emit, str$("("));

        for (int i = 0; i < type->params.length; i++)
        {
            emit_type(interface, &type->params.data[i], emit);

            if (i + 1 != type->params.length)
            {
                emit_fmt(emit, str$(","));
            }
        }

        emit_fmt(emit, str$(")"));
    }
}

static void emit_enum(BidInterface const *interface, BidEnum const *type, Emit *emit)
{
    emit_fmt(emit, "enum {{\n");
    emit_ident(emit);

    vec_foreach(member, &type->members)
    {
        emit_fmt(emit, "{case:upper}_{case:upper},\n", interface->name, member);
    }

    emit_deident(emit);
    emit_fmt(emit, "}}");
}

static void emit_struct(BidInterface const *interface, BidStruct const *type, Emit *emit)
{
    emit_fmt(emit, "struct {{\n");
    emit_ident(emit);

    vec_foreach(member, &type->members)
    {
        emit_type(interface, &member.type, emit);
        emit_fmt(emit, " {};\n", member.name);
    }

    emit_deident(emit);
    emit_fmt(emit, "}}");
}

static void emit_type(BidInterface const *interface, BidType const *type, Emit *emit)
{
    switch (type->type)
    {
    case BID_TYPE_GENERIC:
        emit_generic(interface, &type->generic_, emit);
        break;

    case BID_TYPE_ENUM:
        emit_enum(interface, &type->enum_, emit);
        break;

    case BID_TYPE_STRUCT:
        emit_struct(interface, &type->struct_, emit);
        break;

    default:
        break;
    }
}

void bid2c(BidInterface const *interface, Emit *emit)
{
    emit_fmt(emit, "#pragma once\n"
                   "\n"
                   "// This is file is auto generated by BID, don't edit it!\n"
                   "\n"
                   "#include <syscalls/types.h>\n"
                   "\n");

    emit_fmt(emit, "typedef ");
    emit_enum(interface, &interface->errors, emit);
    emit_fmt(emit, " {case:pascal}Error;\n", interface->name);

    emit_fmt(emit, "\n");

    emit_fmt(emit, "/* --- Types ---------------------------------------------------------------- */\n\n");

    vec_foreach(alias, &interface->aliases)
    {
        emit_fmt(emit, "typedef ");
        emit_type(interface, &alias.type, emit);
        emit_fmt(emit, " {case:pascal}{case:pascal};\n", interface->name, alias.name);
        emit_fmt(emit, "\n");
    }

    emit_fmt(emit, "/* --- Messages ------------------------------------------------------------- */\n\n");

    vec_foreach(method, &interface->methods)
    {
        emit_fmt(emit, "typedef ");
        emit_type(interface, &method.request, emit);
        emit_fmt(emit, " {case:pascal}{case:pascal}Request;\n", interface->name, method.name);

        emit_fmt(emit, "\n");

        emit_fmt(emit, "typedef ");
        emit_type(interface, &method.response, emit);
        emit_fmt(emit, " {case:pascal}{case:pascal}Response;\n", interface->name, method.name);

        emit_fmt(emit, "\n");
    }

    vec_foreach(event, &interface->events)
    {
        emit_fmt(emit, "typedef ");
        emit_type(interface, &event.data, emit);
        emit_fmt(emit, " {case:pascal}{case:pascal}Event;\n", interface->name, event.name);
        emit_fmt(emit, "\n");
    }

    emit_fmt(emit, "typedef enum {{\n");

    emit_ident(emit);

    emit_fmt(emit, "{case:upper}_INVALID,\n", interface->name);
    emit_fmt(emit, "{case:upper}_ERROR,\n", interface->name);

    vec_foreach(method, &interface->methods)
    {
        emit_fmt(emit, "{case:upper}_{case:upper}_REQUEST,\n", interface->name, method.name);
        emit_fmt(emit, "{case:upper}_{case:upper}_RESPONSE,\n", interface->name, method.name);
    }

    vec_foreach(event, &interface->events)
    {
        emit_fmt(emit, "{case:upper}_{case:upper}_EVENT,\n", interface->name, event.name);
    }

    emit_deident(emit);

    emit_fmt(emit, "}} {case:pascal}MessageType;\n", interface->name);

    emit_fmt(emit, "\n");

    emit_fmt(emit, "typedef struct {{\n");

    emit_ident(emit);

    emit_fmt(emit, "BrMsgHeader header;\n");

    emit_fmt(emit, "union {{\n");

    emit_ident(emit);

    emit_fmt(emit, "{case:pascal}Error error;\n", interface->name);

    vec_foreach(event, &interface->events)
    {
        emit_fmt(emit, "{case:pascal}{case:pascal}Event {case:sake}_event;\n", interface->name, event.name, event.name);
    }

    vec_foreach(method, &interface->methods)
    {
        emit_fmt(emit, "{case:pascal}{case:pascal}Request {case:sake}_request;\n", interface->name, method.name, method.name);
        emit_fmt(emit, "{case:pascal}{case:pascal}Response {case:sake}_response;\n", interface->name, method.name, method.name);
    }

    emit_deident(emit);

    emit_fmt(emit, "}};\n");

    emit_deident(emit);

    emit_fmt(emit, "}} {case:pascal}Message;\n", interface->name);
}
